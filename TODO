
New TODO:
 1. replace our current interface to native calls with one based on libffi
 2. re-work variables so we can split out arrays from scalars
 3. keep type info for constants
 4. clean up API
	- make the add variable stuff not return a pointer so we can allocate only
	  as much space as we need for variables (also make the get functions
	  return NULL until we have compiled the compartment) 



TODO: this TODO list is out of date
TODO: In no particular order.
general
 1. Fix Makefile (.d's seem to be somewhat screwy, and test get's made always...)
     Note there may not be a way to make this stop, it's just make generating errors
     when the autogenerated dependancies are not present...  - FIXED
 2. When bytecode is changed make clean is neccessary or compile errors will happen
 3. Make variables/functions/etc dynamicly allocated
 		-needs to change api (adding vars doesn't return pointer anymore, 
 			can't get pointer until after compile)
 
interpreter
 1. add conditional compilation to headers for C++ compiling - DONE!
 3. figure out how to make eclipse build our test case - DONE!
 4. finish API - DONE!
 5. add test cases for entire API
 6. add test cases for all instructions 
 7. Figure out some way to allow interpreter to be terminated if it goes into an
    infinite loop.
 8. figure out how to make debug hooks
 9. 
 
 Change integer max and min, And add a check to configure to see if we have signed shifts.
Integer Minimum or Maximum

Given 2's complement integer values x and y, the minimum can be computed without any branches as x+(((y-x)>>(WORDBITS-1))&(y-x)). Logically, this works because the shift by (WORDBITS-1) replicates the sign bit to create a mask -- be aware, however, that the C language does not require that shifts are signed even if their operands are signed, so there is a potential portability problem. Additionally, one might think that a shift by any number greater than or equal to WORDBITS would have the same effect, but many instruction sets have shifts that behave strangely when such shift distances are specified. 

Of course, maximum can be computed using the same trick: x-(((x-y)>>(WORDBITS-1))&(x-y)). 

Actually, the Integer Selection coding trick is just as efficient in encoding minimum and maximum....


 
======

-- write documentation (Overview/Tutorial)
-- document external API in headers - DONE!


