// $Id$

/*
    CompSL scripting language 
    Copyright (C) 2007  Thomas Jones & John Peberdy

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#ifndef VARS_H_
#define VARS_H_

#include "compsl.h"
#include <stdbool.h>


///< Size of the arithmatic stack 
#define VM_STACK_SIZE 256

///< Maximum number of global variables (note currently cannot be  increased
///< since internal addresses are only 1 byte)
#define VM_MAX_GVARS 256

///< initial size of function table, may be resized? 
#define VM_NATIVEFN_INIT_SIZE 64

#define INT_VAR 0
#define FLOAT_VAR 1
#define IS_ARRAY 2
#define IS_GLBL 4

struct SYMTABLE_T // don't bother with typedef, only here so I can sizeof it later
{
	uint16_t id;
	uint8_t typeflags;// OR together the apropriat flags ex float array = FLOAT_VAR | IS_ARRAY
	char *name; // symbol name
};

/**
 * Holds variables and their symbols, also tracks # of variables in it
 */
typedef struct VAR_TABLE_T
{
	uint16_t capacity; ///< max variables for this table
	uint16_t cnt; ///< number of variables currently in the table
    var *vars; ///< the variables themselves
    struct SYMTABLE_T *symbols; ///< the symbol table for the vars
} varTable;

/** 
 * Represents one paramenter to a native function.
 */
typedef struct native_param_t
{
	bool isFloat; ///< true if the param has type float, false if it's an int
	bool isArray; ///< if the param is an array true, false if it's scalar
} nativeParam;

/**
 * looks after one native function, holds pointer to function and
 * info about number and type of params
 */
typedef struct _nativeFN_t
{
	const char *name;   ///< name of this function
	compsl_nat func;    ///< pointer the function to call

	bool isVoid;        ///<true iff function does not return a value
	bool retFloat;      ///< true iff the return type is a float

	var *params;        ///< the list of paramaters to pass to it
	uint8_t *paramFlags;///< OR together the apropriat flags ex float array = FLOAT_VAR | IS_ARRAY
	uint8_t numParam;   ///< how many paramaters to pass it
} nativeFN;

struct _VM_t
{
    nativeFN *natives; ///< native function table
    uint16_t ncnt;     ///< number of native functions
    
    varTable vt;       ///< variable table, holds global variables
    
    COMPSL_ERROR errorno; ///<holds the error code of the last error generated by this VM
};

/**
 * search for a variable in the specified list
 * returns index if found, -1 otherwise
 * list = list to search
 * name = name of var
 */
COMPSL_INTERN int16_t findVar(const varTable *vt,const char *name) __attribute__ ((pure));

COMPSL_INTERN var *addVar(varTable *vt, uint8_t typeflags, const char *name);

COMPSL_INTERN void varTableCreate(varTable *vt, uint16_t size);
//free up the symbol table and variable values
// also free the names of the vars
COMPSL_INTERN void varTableDestroy(varTable *vt);

COMPSL_INTERN bool var_testEqi(var* a, var* b);
COMPSL_INTERN bool var_testEqf(var* a, var* b);

#endif /*VARS_H_*/
